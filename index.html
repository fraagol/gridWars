<html>

<head>
  <title>GridWars</title>
  <script type="text/javascript">

    const GRID_SIZE = 20;
    const SCALE = 50;
    let hLines = initArray(GRID_SIZE + 1);
    let vLines = initArray(GRID_SIZE + 1);
    let squares = initArray(GRID_SIZE);

    let checkingSquares = initArray(GRID_SIZE + 1);
    let ctx;
    const checkingStyle = "#f2c1f1"


    let players = [];
   /* players.push({ id: 0, style: "rgb(200, 200, 200)" });
    players.push({ id: 1, x: GRID_SIZE / 4, y: GRID_SIZE / 4, style: "#ce4bf1", headColor: "rgb(50,200,200)", move: 0 });
    players.push({ id: 2, x: 3 * GRID_SIZE / 4, y: 3 * GRID_SIZE / 4, style: "#93d2f3", headColor: "rgb(50,200,60)", move: 0 });
    players.push({ id: 3, x: 3 * GRID_SIZE / 4, y: 3 * GRID_SIZE / 4, style: "#ff83eb", headColor: "rgb(0,0,0)", move: 0 });
*/
    function draw() {
      var canvas = document.getElementById('canvas');
      if (canvas.getContext) {
        ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 8;

        resetPlayersScore();

        for (let hIndex = 0; hIndex <= GRID_SIZE; hIndex++) {
          for (let vIndex = 0; vIndex <= GRID_SIZE; vIndex++) {
            drawSquares(hIndex, vIndex);
            drawHLine(hIndex, vIndex);
            drawVLine(hIndex, vIndex);
            drawPlayers();
            if (checkingSquares[hIndex][vIndex] == 1) {
              drawCheckingSquare(hIndex, vIndex);
            }
            if (hIndex < GRID_SIZE && vIndex < GRID_SIZE) {
              let squareOwner = squares[hIndex][vIndex];
              players[squareOwner].score++;
            }
          }
        }

        ctx.fillStyle = "rgb(230, 230, 230)";
        ctx.strokeStyle = "rgb(230, 230, 230)";
        for (var x = 0; x <= GRID_SIZE; x++) {
          for (var y = 0; y <= GRID_SIZE; y++) {
            ctx.beginPath();
            ctx.arc(x * SCALE, y * SCALE, 2, 0, 2 * Math.PI);
            ctx.fill();
          }


        }
      }
      updateScoreboard();
    }

    function drawSquares(x, y) {
      // if(drawCheckingSquare[x][y])
      const square = squares[x][y];
      // console.log("drawing square " + x +" "+  y + " with color " + players[square].style)
      ctx.beginPath();
      ctx.fillStyle = players[square].style;
      ctx.fillRect((x * SCALE), (y * SCALE), SCALE, SCALE);
      // ctx.fillRect((x * SCALE) + 0, (y * SCALE) + 0, SCALE - 0, SCALE - 0);
      //ctx.stroke();
    }


    function drawCheckingSquare(x, y) {
      console.log("drawing checking  " + x + " " + y + " with color " + checkingStyle)
      ctx.beginPath();
      ctx.fillStyle = checkingStyle;
      ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);
      ctx.stroke();
    }

    function drawHLine(x, y) {
      const line = hLines[x][y];
      if (line > 0) {
        ctx.fillStyle = players[line].headColor;
        ctx.beginPath();
        //   ctx.fillRect(player.x*SCALE, player.y*SCALE, player.vx==0?10:player.vx*SCALE, player.vy==0?10:player.vy*SCALE);
        ctx.strokeStyle = players[line].headColor;
        ctx.moveTo(x * SCALE, y * SCALE);
        ctx.lineTo((x + 1) * SCALE, y * SCALE);
        ctx.stroke();
      }
    }
    function drawVLine(x, y) {
      const line = vLines[x][y];
      if (line > 0) {

        ctx.fillStyle = players[line].headColor;
        ctx.beginPath();
        //   ctx.fillRect(player.x*SCALE, player.y*SCALE, player.vx==0?10:player.vx*SCALE, player.vy==0?10:player.vy*SCALE);
        ctx.strokeStyle = players[line].headColor;
        ctx.moveTo(x * SCALE, y * SCALE);
        ctx.lineTo(x * SCALE, (y + 1) * SCALE);
        ctx.stroke();
      }
    }

    function drawPlayers() {
      players.forEach(player => {
        ctx.beginPath();
        ctx.fillStyle = player.headColor;
        ctx.arc(player.x * SCALE, player.y * SCALE, 10, 0, 2 * Math.PI);

        ctx.fill();
      });

    }

    function resetPlayersScore() {
      for (let index = 0; index < players.length; index++) {
        const player = players[index];
        player.score = 0;

      }
    }
    function updateScoreboard() {
      //   console.log(`score: ${players[0].score}, ${players[1].score}, ${players[2].score}`);
      const scoreboard = document.getElementById("scoreboard");
      scoreboard.textContent = `score: ${players[0].score}, ${players[1].score}, ${players[2].score}`;
    }

    function initArray(n) {
      return new Array(n).fill(0).map(() => new Array(n).fill(0));
    }
  </script>
  <style type="text/css">
    canvas {
      border: 0px solid black;
    }
  </style>
</head>

<body>
  <div style="display: flex; justify-content: center;">
    <canvas id="canvas" width="1000" height="1000" style="border: 1px solid black;"></canvas>
    <div id="scoreboard" style="border: 1px solid black; width: 200px; height: 1000px;"> hola</div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    var socket = io();

    socket.on('sendStatus', function (msg) {
      hLines = msg.hLines;
      vLines = msg.vLines;
      squares = msg.squares;
      players = msg.players;
      for (let p = 1; p < msg.players.length; p++) {
        const player = msg.players[p];
        players[p].x = msg.players[p].x;
        players[p].y = msg.players[p].y;
      }
      draw()
    });

    socket.on('debug', function (msg) {
      console.log(msg.player.name);

    });

    socket.on('checkingSquare', function (msg) {
      checkingSquares[msg.x][msg.y] = 1;
      draw();

    });

    socket.on('clearCheck', function (msg) {
      checkingSquares = initArray(GRID_SIZE + 1)
      draw();

    });

    socket.on('closedArea', function (msg) {
      const { player, closedArea } = msg;
      checkingSquares = initArray(GRID_SIZE + 1)
      draw();

    });


    socket.io.on("reconnect", (attempt) => {
      console.log("reconnecting!!!!");
      location.reload();
    });



  </script>
</body>

</html>